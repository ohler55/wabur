;; -*- mode: outline; outline-regexp: " *[-\+]"; indent-tabs-mode: nil -*-


- UI config
 - option to load from backend
 - if wab.setFlow is called then use that else get from backend
  - how to do that when wab file comes first, that is the trigger
   - maybe always try and if non-null is returned use that and let setFlow over-ride
 - WAB::UI objects
  - need to specify in conf
   - for opo-rub it is the setup code
   - for wabur ui.config class
  - Flow - basically a Hash
   - method to return a Hash that becomes JSON for UI
  - Display - describes display
  - Field - describe each field
 - optons in graphical builder to generate ruby, js, or json

 - note this is driven by the view js code with help from ruby
  - note required, can use any front end (emphasize CLI comment)

- can a default controller be used?
 - if started with no controller, use a basic rest controller
  - WAB::OpenController - all methods open
  - with warning or info if not specified
  

- tutorial
 - note MVC parts in diagram
 - note separation of server side and client side
  - describe server side as JSON data manager
   - model stores and retrieves
   - controller combines, changes, enhances, etc (provides a view onto data)


1) Add a WAB::OpenController that is used as a default with a warning if no others specified.
2) Allow for a the UI configuration to be specified with WAB::UI classes for the reference implementation.
3) Rework lesson-1.

- more knowledge of objects in controller?
 - method to return fields (type, default, structure)
  - return of nil means anything
  - how to specify anything goes? null?

 - get ui flow info from controller (a config option)
 - force templates?



- goal of more ruby
 - for UI config
  - conf.js
  - custom js
  - get from shell/server
   - has to match up with loaded js of course
   - ref impl would attempt load from shell on configured ui paths (with default /v1/ui)
   - if conf.js is loaded it should call wab.setFlow
 - how to depends on ref impl
  - use a flow spec?
  - use html templates with id
   -


- ui is element with ids
 - wab walks div and any child with an id beginning with 'obj.<path>' gets pulled into object
 - pass json map to UI as key: <html code> ?
  - not as flexible
 - 

For the UI it seems that you feel people will shy away from a predominantly JavaScript approach so let me try some ideas to increate Ruby and basic HTML use.

First, allow a conf.js or what  ever the developer wants to call it. I'll back away from the idea of using a completely data driven UI for now in favor of an approach that requires writing JavaScript classes. What I mean by that is the developer writes their own JavaScript code and attaches the functions to an object. We will provide the pattern for that. So, if the developer goes with the conf.js approach they will have to write JavaScript or something that generates JavaScript. This is not the lesson-1 approach.

Using the conf.js approach a UI flow with a data drive UI is possible and may be something we look at in the future. Not right now though.

Now the beginner, Ruby developer approach or the WAB reference implementation. From the developer perspective all they have to do is use or subclass and use the WAB::UI::RestFlow class that describes the object to manage. The blog Entry object for example.

Behind the scenes, on loading the wab module (wab.js) a request is made to the shell on a predetermined URL path. Maybe '/v1/ui`. An override set before loading wab.js could change that path. Anyway the server (runner) would respond with a JSON object (a Hash) that had attributes or keys to identify a display by name and the value for those display name would be an HTML string. This map and the HTML strings would be generated by the WAB::UI::RestFlow class/object.

The WAB::UI::RestFlow will call on WAB::UI::Display objects to put together the map returned to the UI. Each display object can either have a hard coded HTML template, load the HTML template from a file, or generate it by Ruby code. With various Display subclasses there are quite a few directions we can take this and stay pure Ruby for the Developer.

Now, on the UI side wab would receive the display map and create and cache display element from the HTML provided. When a user goes to a display by clicking on some button wab will find the display in the map and show it.

What this approach gives us is:

1) The Controller remains separate from the View but both can be coded in Ruby.

2) Flexibility to use JavaScript, HTML/CSS, or Ruby for UI development.

3) Leaves the door open for multiple UI implementations with the same server side components by tagging the Ruby code registration with the shell.

If this seems like the right direction I'll update the tutorial, implement the shell additions, and then the JavaScript code.

What do you think?

-Pete
